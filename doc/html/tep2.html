<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.4: http://docutils.sourceforge.net/" />
<title>Hardware Abstraction Architecture</title>
<meta name="author" content="Vlado Handziski, Joseph Polastre, Jan-Hinrich Hauer, Cory Sharp, Adam Wolisz and David Culler" />
<style type="text/css">

/*
:Author: David Goodger
:Contact: goodger@users.sourceforge.net
:date: $Date: 2006-11-07 19:30:38 $
:version: $Revision: 1.5 $
:copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.
*/
body {
  font-family: Times;
  font-size: 16px;
}

.first {
  margin-top: 0 ! important }

.last {
  margin-bottom: 0 ! important }

.hidden {
  display: none }

a.toc-backref {
  text-decoration: none ;
  color: black }

blockquote.epigraph {
  margin: 2em 5em ; }

dd {
  margin-bottom: 0.5em }

/* Uncomment (& remove this text!) to get bold-faced definition list terms
dt {
  font-weight: bold }
*/

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.attention, div.caution, div.danger, div.error, div.hint,
div.important, div.note, div.tip, div.warning, div.admonition {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

div.hint p.admonition-title, div.important p.admonition-title,
div.note p.admonition-title, div.tip p.admonition-title,
div.admonition p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em }

div.footer, div.header {
  font-size: smaller }

div.line-block {
  display: block ;
  margin-top: 1em ;
  margin-bottom: 1em }

div.line-block div.line-block {
  margin-top: 0 ;
  margin-bottom: 0 ;
  margin-left: 1.5em }

div.sidebar {
  margin-left: 1em ;
  border: medium outset ;
  padding: 0em 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1 {
  font-family: Arial, sans-serif;
  font-size: 20px;
}

h1.title {
 text-align: center;
 font-size: 32px;
}

h2 {
 font-size: 16px;
 font-family: Arial, sans-serif;
}

h2.subtitle {
  text-align: center }

h3 {
 font-size: 12px;
 font-family: Arial, sans-serif;
}

hr {
  width: 75% }

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font-family: serif ;
  font-size: 100% }

pre.line-block {
  font-family: serif ;
  font-size: 100% }

pre.literal-block, pre.doctest-block {
  margin-left: 2em ;
  margin-right: 2em ;
  background-color: #eeeeee;
  border-color: #000000;
  border-width: thin; 
  font-size: 14px
}

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.option-argument {
  font-style: italic }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

table {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.citation {
  border-left: solid thin gray ;
  padding-left: 0.5ex }

table.docinfo {
  margin: 2em 4em;
}

table.footnote {
  border-left: solid thin black ;
  padding-left: 0.5ex }

td, th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

th.docinfo-name, th.field-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap;
  }

h1 tt, h2 tt, h3 tt, h4 tt, h5 tt, h6 tt {
  font-size: 100% }

tt {}

ul.auto-toc {
  list-style-type: none }

</style>
</head>
<body>
<div class="document" id="hardware-abstraction-architecture">
<h1 class="title">Hardware Abstraction Architecture</h1>
<table class="docinfo" frame="void" rules="none">
<col class="docinfo-name" />
<col class="docinfo-content" />
<tbody valign="top">
<tr class="field"><th class="docinfo-name">TEP:</th><td class="field-body">2</td>
</tr>
<tr class="field"><th class="docinfo-name">Group:</th><td class="field-body">Core Working Group</td>
</tr>
<tr class="field"><th class="docinfo-name">Type:</th><td class="field-body">Best Current Practice</td>
</tr>
<tr><th class="docinfo-name">Status:</th>
<td>Draft</td></tr>
<tr class="field"><th class="docinfo-name">TinyOS-Version:</th><td class="field-body">2.0</td>
</tr>
<tr><th class="docinfo-name">Author:</th>
<td>Vlado Handziski, Joseph Polastre, Jan-Hinrich Hauer, Cory Sharp, Adam Wolisz and David Culler</td></tr>
<tr class="field"><th class="docinfo-name">Draft-Created:</th><td class="field-body">14-Sep-2004</td>
</tr>
<tr class="field"><th class="docinfo-name">Draft-Version:</th><td class="field-body">$revision$</td>
</tr>
<tr class="field"><th class="docinfo-name">Draft-Modified:</th><td class="field-body">$date$</td>
</tr>
<tr class="field"><th class="docinfo-name">Draft-Discuss:</th><td class="field-body">TinyOS Developer List &lt;tinyos-devel at mail.millennium.berkeley.edu&gt;</td>
</tr>
</tbody>
</table>
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last">This document specifies a Best Current Practices for the TinyOS
Community, and requests discussion and suggestions for
improvements.  The distribution of the memo is unlimited, provided
that the header information and this note are preserved. Parts of
this document are taken verbatim from the <a class="citation-reference" href="#haa2005" id="id1" name="id1">[HAA2005]</a> paper that is
under IEEE copyright. This memo is in full compliance with <a class="citation-reference" href="#tep1" id="id2" name="id2">[TEP1]</a>.</p>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id16" id="abstract" name="abstract">1&nbsp;&nbsp;&nbsp;Abstract</a></h1>
<p>This TEP documents the <em>Hardware Abstraction Architecture (HAA)</em> for TinyOS
2.0 that balances conflicting requirements of WSN applications and the
desire for increased portability and streamlined development of
applications. The three-layer design gradually adapts the capabilities
of the underlying hardware platforms to the selected
platform-independent hardware interface between the operating system
core and the application code. At the same time, it allows the
applications to utilize a platform's full capabilities -- exported at
the second layer, when the performance requirements outweigh the need
for cross-platform compatibility.</p>
<!-- We demonstrate the practical value of the approach by presenting
how it can be applied to the most important hardware modules that
are found in a typical WSN platform. We support the claims using
concrete examples from existing hardware abstractions in TinyOS
and the implementation of the MSP430 platform that follows the
architecture proposed in this paper. -->
</div>
<div class="section">
<h1><a class="toc-backref" href="#id17" id="table-of-contents" name="table-of-contents">2&nbsp;&nbsp;&nbsp;Table of Contents</a></h1>
<div class="contents topic">
<p class="topic-title first"><a id="contents" name="contents">Contents</a></p>
<ul class="auto-toc simple">
<li><a class="reference" href="#abstract" id="id16" name="id16">1&nbsp;&nbsp;&nbsp;Abstract</a></li>
<li><a class="reference" href="#table-of-contents" id="id17" name="id17">2&nbsp;&nbsp;&nbsp;Table of Contents</a></li>
<li><a class="reference" href="#introduction" id="id18" name="id18">3&nbsp;&nbsp;&nbsp;Introduction</a></li>
<li><a class="reference" href="#architecture" id="id19" name="id19">4&nbsp;&nbsp;&nbsp;Architecture</a><ul class="auto-toc">
<li><a class="reference" href="#hardware-presentation-layer-hpl" id="id20" name="id20">4.1&nbsp;&nbsp;&nbsp;Hardware Presentation Layer (HPL)</a></li>
<li><a class="reference" href="#hardware-adaptation-layer-hal" id="id21" name="id21">4.2&nbsp;&nbsp;&nbsp;Hardware Adaptation Layer (HAL)</a></li>
<li><a class="reference" href="#hardware-interface-layer-hil" id="id22" name="id22">4.3&nbsp;&nbsp;&nbsp;Hardware Interface Layer (HIL)</a></li>
<li><a class="reference" href="#selecting-the-level-of-abstraction" id="id23" name="id23">4.4&nbsp;&nbsp;&nbsp;Selecting the level of abstraction</a></li>
</ul>
</li>
<li><a class="reference" href="#reference" id="id24" name="id24">5&nbsp;&nbsp;&nbsp;Reference</a><ul class="auto-toc">
<li><a class="reference" href="#processing-unit" id="id25" name="id25">5.1&nbsp;&nbsp;&nbsp;Processing unit</a></li>
<li><a class="reference" href="#power-management" id="id26" name="id26">5.2&nbsp;&nbsp;&nbsp;Power management</a></li>
<li><a class="reference" href="#clocks-and-timers" id="id27" name="id27">5.3&nbsp;&nbsp;&nbsp;Clocks and timers</a></li>
<li><a class="reference" href="#analog-to-digital-converters" id="id28" name="id28">5.4&nbsp;&nbsp;&nbsp;Analog-to-digital converters</a></li>
<li><a class="reference" href="#data-busses" id="id29" name="id29">5.5&nbsp;&nbsp;&nbsp;Data busses</a></li>
<li><a class="reference" href="#external-storage" id="id30" name="id30">5.6&nbsp;&nbsp;&nbsp;External storage</a></li>
<li><a class="reference" href="#radios" id="id31" name="id31">5.7&nbsp;&nbsp;&nbsp;Radios</a></li>
</ul>
</li>
<li><a class="reference" href="#conclusion" id="id32" name="id32">6&nbsp;&nbsp;&nbsp;Conclusion</a></li>
<li><a class="reference" href="#author-s-address" id="id33" name="id33">7&nbsp;&nbsp;&nbsp;Author's Address</a></li>
<li><a class="reference" href="#citations" id="id34" name="id34">8&nbsp;&nbsp;&nbsp;Citations</a></li>
</ul>
</div>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id18" id="introduction" name="introduction">3&nbsp;&nbsp;&nbsp;Introduction</a></h1>
<p>The introduction of hardware abstraction in modern operating systems
has proved valuable for increasing portability and simplifying
application development by hiding the hardware intricacies from the
rest of the system. Although enabling portability, hardware
abstractions come into conflict with the performance and
energy-efficiency requirements of WSN applications.</p>
<p>We need a <em>Hardware Abstraction Architecture (HAA)</em> that can strike a
balance between the above conflicting goals. The component-based model
of TinyOS has the functionality required for resolving this
tension. The main challenge is to select an appropriate organization
of abstraction functionality in form of components to support
reusability while maintaining energy-efficiency through access to the
full hardware capabilities when it is needed.</p>
<p>Based on the experience in porting TinyOS to new platforms we believe
that an effective organization is possible when the strengths of the
component-based approach are combined with a flexible, three-tier
organization of the hardware abstraction architecture.</p>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id19" id="architecture" name="architecture">4&nbsp;&nbsp;&nbsp;Architecture</a></h1>
<p>In the proposed architecture (<a class="reference" href="#fig-1">Fig.1</a>), the hardware abstraction
functionality is organized in three distinct layers of components.
Each layer has clearly defined responsibilities and is dependent on
interfaces provided by lower layers.  The capabilities of the
underlying hardware are gradually adapted to the established
platform-independent interface between the operating system and the
applications. As we move from the hardware towards this top interface,
the components become less and less hardware dependent, giving the
developer more freedom in the design and the implementation of
reusable applications.</p>
<pre class="literal-block" id="fig-1">
                                +-----------------------------+
                                |                             |
                                | Cross-platform applications |
                                |                             |
                                +--------------+--------------+
+-----------------+                            |                            +-----------------+
|Platform-specific|                            |                            |Platform-specific|
|  applications   |                            |                            |  applications   |
+--------+--------+       Platform-independent |  hardware interface        +--------+--------+
         |          +-----------------+--------+--------+-----------------+          |
         |          |                 |                 |                 |          |
         |  +-------+-------+ +-------+-------+ +-------+-------+ +-------+-------+  |
         |  |.------+------.| |.------+------.| |.------+------.| |.------+------.|  |
         |  ||             || ||             || ||             || ||    HIL 4    ||  |
         |  ||    HIL 1    || ||    HIL 2    || ||    HIL 3    || |`------+------'|  |
         |  ||             || |`------+------'| |`------+------'| |       |       |  |
         |  |`------+------'| |       |       | |       |       | |       |  +----+--+
         +--+----+  |       | |.------+------.| |       |       | |       |  |    |
            |    |  |       | ||             || |.------+------.| |.------+--+---.|
            |.---+--+------.| ||             || ||             || ||             ||
            ||             || ||    HAL 2    || ||             || ||             ||
            ||             || ||             || ||    HAL 3    || ||    HAL 4    ||
            ||    HAL 1    || |`------+------'| ||             || ||             ||
            ||             || |       |       | ||             || ||             ||
            ||             || |       |       | |`------+------'| |`------+------'|
            |`------+------'| |.------+------.| |       |       | |       |       |
            |       |       | ||             || |.------+------.| |       |       |
            |.------+------.| ||    HPL 2    || ||             || |.------+------.|
            ||    HPL 1    || ||             || ||    HPL 3    || ||    HPL 4    ||
            |`------+------'| |`------+------'| |`------+------'| |`------+------'|
            +-------+-------+ +-------+-------+ +-------+-------+ +-------+-------+  HW/SW
                    |                 |                 |                 |          boundary
       ************************************************************************************
             +------+------+   +------+------+   +------+------+   +------+------+
             |HW Platform 1|   |HW Platform 2|   |HW Platform 3|   |HW Platform 4|
             +-------------+   +-------------+   +-------------+   +-------------+


                      Fig.1: The proposed Hardware Abstraction Architecture
</pre>
<div class="section">
<h2><a class="toc-backref" href="#id20" id="hardware-presentation-layer-hpl" name="hardware-presentation-layer-hpl">4.1&nbsp;&nbsp;&nbsp;Hardware Presentation Layer (HPL)</a></h2>
<p>The components belonging to the <em>HPL</em> are positioned directly over
the HW/SW interface. As the name suggests, their major task is to
&quot;present&quot; the capabilities of the hardware using the native concepts
of the operating system.  They access the hardware in the usual way,
either by memory or by port mapped I/O. In the reverse direction, the
hardware can request servicing by signaling an interrupt. Using these
communication channels internally, the <em>HPL</em> hides the hardware
intricacies and exports a more usable interface (simple function
calls) for the rest of the system.</p>
<p>The <em>HPL</em> components SHOULD be stateless and expose an interface
that is fully determined by the capabilities of the hardware module
that is abstracted. This tight coupling with the hardware leaves
little freedom in the design and the implementation of the components.
Even though each <em>HPL</em> component will be as unique as the underlying
hardware, all of them will have a similar general structure. For
optimal integration with the rest of the architecture, each <em>HPL</em>
component SHOULD have:</p>
<ul class="simple">
<li>commands for initialization, starting, and stopping of the
hardware module that are necessary for effective power management
policy</li>
<li>&quot;get&quot; and &quot;set&quot; commands for the register(s) that control
the operation of the hardware</li>
<li>separate commands with descriptive names for the most
frequently used flag-setting/testing operations</li>
<li>commands for enabling and disabling of the interrupts generated by
the hardware module</li>
<li>service routines for the interrupts that are generated by the
hardware module</li>
</ul>
<p>The interrupt service routines in the <em>HPL</em> components perform only
the most time critical operations (like copying a single value,
clearing some flags, etc.), and delegate the rest of the processing to
the higher level components that possess extended knowledge about the
state of the system.</p>
<p>The above <em>HPL</em> structure eases manipulation of the hardware.
Instead of using cryptic macros and register names whose definitions
are hidden deep in the header files of compiler libraries, the
programmer can now access hardware through a familiar interface.</p>
<p>This <em>HPL</em> does not provide any substantial abstraction over the
hardware beyond automating frequently used command
sequences. Nonetheless, it hides the most hardware-dependent code and
opens the way for developing higher-level abstraction components.
These higher abstractions can be used with different <em>HPL</em>
hardware-modules of the same class.  For example, many of the
microcontrollers used on the existing WSN platforms have two USART
modules for serial communication.  They have the same functionality
but are accessed using slightly different register names and generate
different interrupt vectors. The <em>HPL</em> components can hide these
small differences behind a consistent interface, making the
higher-level abstractions resource independent.  The programmer can
then switch between the different USART modules by simple rewiring
(<em>not</em> rewriting) the <em>HPL</em> components, without any changes to the
implementation code.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id21" id="hardware-adaptation-layer-hal" name="hardware-adaptation-layer-hal">4.2&nbsp;&nbsp;&nbsp;Hardware Adaptation Layer (HAL)</a></h2>
<p>The adaptation layer components represent the core of the
architecture. They use the raw interfaces provided by the <em>HPL</em>
components to build useful abstractions hiding the complexity
naturally associated with the use of hardware resources. In contrast
to the <em>HPL</em> components, they are allowed to maintain state that can
be used for performing arbitration and resource control.</p>
<p>Due to the efficiency requirements of WSN, abstractions at the <em>HAL</em>
level are tailored to the concrete device class and platform. Instead
of hiding the individual features of the hardware class behind generic
models, <em>HAL</em> interfaces expose specific features and provide the
&quot;best&quot; possible abstraction that streamlines application development
while maintaining effective use of resources.</p>
<p>For example, rather than using a single &quot;file-like&quot; abstraction for
all devices, we propose domain specific models like <em>Alarm</em>, <em>ADC
channel</em>, <em>EEPROM</em>. According to the model, <em>HAL</em> components SHOULD
provide access to these abstractions via rich, customized interfaces,
and not via standard narrow ones that hide all the functionality
behind few overloaded commands.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id22" id="hardware-interface-layer-hil" name="hardware-interface-layer-hil">4.3&nbsp;&nbsp;&nbsp;Hardware Interface Layer (HIL)</a></h2>
<p>The final tier in the architecture is formed by the <em>HIL</em> components
that take the platform-specific abstractions provided by the <em>HAL</em> and
convert them to hardware-independent interfaces used by cross-platform
applications.  These interfaces provide a platform independent
abstraction over the hardware that simplifies the development of the
application software by hiding the hardware differences.  To be
successful, this API &quot;contract&quot; SHOULD reflect the <em>typical</em>
hardware services that are required in a WSN application.</p>
<p>The complexity of the <em>HIL</em> components mainly depends on how advanced
the capabilities of the abstracted hardware are with respect to the
platform-independent interface. When the capabilities of the hardware
exceed the current API contract, the <em>HIL</em> &quot;downgrades&quot; the
platform-specific abstractions provided by the <em>HAL</em> until they are
leveled-off with the chosen standard interface. Consequently, when the
underlying hardware is inferior, the <em>HIL</em> might have to resort to
software simulation of the missing hardware capabilities.  As newer
and more capable platforms are introduced in the system, the pressure
to break the current API contract will increase. When the performance
requirements outweigh the benefits of the stable interface, a discrete
jump will be made that realigns the API with the abstractions provided
in the newer <em>HAL</em>.  The evolution of the platform-independent interface
will force a reimplementation of the affected <em>HIL</em> components. For
newer platforms, the <em>HIL</em> will be much simpler because the API contract
and their <em>HAL</em> abstractions are tightly related. On the other extreme,
the cost of boosting up (in software) the capabilities of the old
platforms will rise.</p>
<p>Since we expect <em>HIL</em> interfaces to evolve as new platforms are
designed, we must determine when the overhead of software emulation of
hardware features can no longer be sustained.  At this point, we
introduce <em>versioning</em> of <em>HIL</em> interfaces.  By assigning a version
number to each iteration of an <em>HIL</em> interface, we can design
applications using a legacy interface to be compatible with previously
deployed devices.  This is important for WSNs since they execute
long-running applications and may be deployed for years.  An <em>HIL</em> MAY
also branch, providing multiple different <em>HIL</em> interfaces with
increasing levels of functionality.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id23" id="selecting-the-level-of-abstraction" name="selecting-the-level-of-abstraction">4.4&nbsp;&nbsp;&nbsp;Selecting the level of abstraction</a></h2>
<p>The platform-dependence of the <em>HAL</em> in the architecture leads to the
more general question about why we have opted for a three-layered
design. In other words, why we do not expose the platform-independent
hardware interface directly from the <em>HAL</em> components. The main reason
behind this decision is the increased <em>flexibility</em> that arises from
separating the platform-specific abstractions and the adaptation
wrappers that upgrade or downgrade them to the current
platform-independent interface.  In this way, for maximum performance,
the platform specific applications can circumvent the <em>HIL</em> components
and directly tap to the <em>HAL</em> interfaces that provide access to the full
capabilities of the hardware module.</p>
<p>Selecting the &quot;right&quot; level--whether an application should use the <em>HIL</em>
or directly access the <em>HAL</em>--can sometimes cause one hardware asset to
be accessed using two levels of abstraction from different parts of
the application or the OS libraries.</p>
<p>Let us take an application similar to the standard OscilloscopeRF
application in TinyOS as an example.  The application uses the ADC to
sample several values from a temperature sensor and sends them in the
form of a message over the radio.  If the observed phenomenon does not
have a large signal bandwidth and the time between subsequent
conversions is long, for the sake of cross-platform compatibility, the
programmer might decide to use the standard <tt class="docutils literal"><span class="pre">ADCSingle</span></tt>
interface. This interface is exported by the <em>HIL</em> sensor wrapper
(<a class="reference" href="#fig-2">Fig.2</a>) using the services of the platform-specific <em>HAL</em>
component. When enough samples are collected in the message buffer,
the application passes the message to the networking stack.  The MAC
protocol used for message exchange over the radio uses clear channel
assessment to determine when it is safe to send the message. This
usually requires taking several samples of the RSSI signal provided by
the radio hardware. Since this is a very time critical operation in
which the correlation between the consecutive samples has a
significant influence, the programmer of the MAC might directly use
the <tt class="docutils literal"><span class="pre">MSP430ADC12Multiple</span></tt> interface of the <em>HAL</em> component as it
provides much finer control over the conversion process.</p>
<pre class="literal-block" id="fig-2">
StdControl
       | ADCSingle
       |    |  ADCMultiple
       |    |    |
+------|----|----|------------------------------------------+
|      |    |    |                            Temperature   |
|      v    v    v                                          |
| +--------------------+ MSP430ADC12Single   +------------+ |
| |   TemperatureM     |--------------------&gt;|MSP430ADC12C| |
| |                    | MSP430ADC12Multiple |            | |
| |                    |--------------------&gt;|            | |
| +--------------------+                     +------------+ |
+-----------------------------------------------------------+

           Fig.2: The ADC HIL sensor wrapper
</pre>
<p>As a result of this chain of decisions, we end up with a concurrent
use of the ADC hardware module using two different levels of
abstraction. To support this type of &quot;vertical&quot; flexibility we include
more complex arbitration and resource control functionality in the <em>HAL</em>
components so that a safe shared access to the <em>HPL</em> exported resources
can be guaranteed.</p>
</div>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id24" id="reference" name="reference">5&nbsp;&nbsp;&nbsp;Reference</a></h1>
<p>The proposed HAA was applied for the first time during the
implementation of the <a class="reference" href="http://cvs.sourceforge.net/viewcvs.py/tinyos/tinyos-1.x/tos/platform/msp430/">MSP430 platform</a> that abstracts the
capabilities of the TI MSP430 microcontroller in <a class="reference" href="http://www.tinyos.net/scoop/section/Releases">TinyOS 1.1.7</a>. The
implementation is currently being used by four hardware platforms
(TelosA, TelosB, eyesIFX and eyesIFXv2) and has quite successfully
satisfied the requirements of a large range of applications.</p>
<p>In the following we illustrate the properties of the proposed
architecture using real-world examples from the planned hardware
abstraction functionality in TinyOS 2.0.</p>
<div class="section">
<h2><a class="toc-backref" href="#id25" id="processing-unit" name="processing-unit">5.1&nbsp;&nbsp;&nbsp;Processing unit</a></h2>
<p>In TinyOS most of the variability between the processing units is
hidden from the OS simply by using a nesC/C based programming language
with a common compiler suite (GCC). For example, the standard library
distributed with the compiler creates the necessary start-up code for
initializing the global variables, the stack pointer and the interrupt
vector table, shielding the OS from these MCU-specific tasks.</p>
<p>To unify things further, TinyOS provides mechanisms for declaring
reentrant and non-reentrant interrupt service routines and critical
code-sections.  For the MCU's external pins, it provides macros that
permit setting and clearing the pin, as well as changing its direction
and function.  For example, the TI~MSP430's ADC pins may be used as
either general I/O or as an analog input to the ADC hardware module.
Macros are also provided for timed spin loops at microsecond
resolution, independent of the microcontroller. These macros are
defined in each platform's <tt class="docutils literal"><span class="pre">hardware.h</span></tt> descriptor file. Finally,
the <em>HPL</em> components deal with the different ways of accessing
registers (memory-mapped or port-mapped I/O) using the definitions in
the standard library header files.</p>
<p>The three-layer architecture is not intended to abstract the features
of the different MCU cores. For the currently supported MCUs, the
combination of the compiler suite support with the thin abstraction in
the <tt class="docutils literal"><span class="pre">hardware.h</span></tt> files is sufficient. Nevertheless, if new cores
with radically different architectures need to be supported by TinyOS
in the future, this part of the hardware abstraction functionality
will have to be explicitly addressed.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id26" id="power-management" name="power-management">5.2&nbsp;&nbsp;&nbsp;Power management</a></h2>
<p>On both the MSP430 and the Atmel, before entering a sleep mode, a
component checks if any hardware modules require that the MCU core is
active.  Additionally, all services including <em>HPL</em> and <em>HAL</em>
components have a start and stop function.  When a service is no
longer using a hardware module, it may call the stop function of the
<em>HPL</em> or <em>HAL</em> component.  Doing so disables the module for power
savings, but also removes the MCU's dependence on that hardware module
to enter sleep mode.  For example, the ADC module may be clocked from
a high speed oscillator.  When a sample is not in progress, the ADC
module may be shut down and it will no longer use the high speed
oscillator.  As a result, when the MCU is idle, it may enter low power
mode.</p>
<p>This rather efficient way of implementing the power management
functionality is made possible by the fact that most of the hardware
modules are on-chip, attached directly to the MCU system bus, and that
there is no hardware memory protection hindering the access to their
status registers. As TinyOS platforms add more external devices
connected via the peripheral buses, this task will get increasingly
complicated.  Ultimately, keeping some state in the form of device
enumeration or reference counting mechanisms might be needed for
proper power management.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id27" id="clocks-and-timers" name="clocks-and-timers">5.3&nbsp;&nbsp;&nbsp;Clocks and timers</a></h2>
<p>The application of the HAA for abstracting the clock and timer
modules is documented in <a class="citation-reference" href="#tep102" id="id3" name="id3">[TEP102]</a>.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id28" id="analog-to-digital-converters" name="analog-to-digital-converters">5.4&nbsp;&nbsp;&nbsp;Analog-to-digital converters</a></h2>
<p>The application of the HAA for abstracting the analog-to-digital
converter modules is documented in <a class="citation-reference" href="#tep101" id="id4" name="id4">[TEP101]</a>.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id29" id="data-busses" name="data-busses">5.5&nbsp;&nbsp;&nbsp;Data busses</a></h2>
<p>The <em>HPL</em> functionality for the data busses includes two paths--one
for data and a second for control. The control path allows the clock
source, prescaler, and baud rate to be set. Interrupts may be enabled
or disabled and various hardware flags may be read, set, or cleared,
useful for polling or blocking implementations. Through the control
path, the entire module may be started or stopped for power control.
The data interface simply consists of sending and receiving a byte
through the hardware's data registers, as well as interrupt based
reporting of received data. Here is an example of the interfaces used
in the MSP430 platform:</p>
<pre class="literal-block">
interface HPLUSARTControl {
  async command void enableUART();
  async command void disableUART();
  async command void enableUARTTx();
  async command void disableUARTTx();
  async command void enableUARTRx();
  async command void disableUARTRx();
  async command void enableSPI();
  async command void disableSPI();
  async command void setModeSPI();
  async command void setModeUART_TX();
  async command void setModeUART_RX();
  async command void setModeUART();
  async command void setClockSource(
        uint8_t source);
  async command void setClockRate(
        uint16_t baudrate, uint8_t mctl);
  async command result_t disableRxIntr();
  async command result_t disableTxIntr();
  async command result_t enableRxIntr();
  async command result_t enableTxIntr();
  async command result_t isTxIntrPending();
  async command result_t isRxIntrPending();
  async command result_t isTxEmpty();
  async command result_t tx(uint8_t data);
  async command uint8_t rx();
}

interface HPLUSARTFeedback {
  async event result_t txDone();
  async event result_t rxDone(uint8_t data);
}
</pre>
<p>Sometimes functionality for more than one bus protocol are supported
through a single hardware module. In these cases, wrappers for each
bus provide standard application interfaces for using the bus.
Sharing the bus amongst different hardware devices or protocols may be
done through a bus arbitration component. Bus arbitration allows
higher level services to attain exclusive use of the bus, complete its
operations, and then release the bus to the next service:</p>
<pre class="literal-block">
interface BusArbitration {
  async command result_t getBus();
  async command result_t releaseBus();
  event result_t busFree();
}
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id30" id="external-storage" name="external-storage">5.6&nbsp;&nbsp;&nbsp;External storage</a></h2>
<p>The application of the HAA for abstracting the external storage
modules is documented in <a class="citation-reference" href="#tep103" id="id5" name="id5">[TEP103]</a>.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id31" id="radios" name="radios">5.7&nbsp;&nbsp;&nbsp;Radios</a></h2>
<p>The application of the HAA for abstracting the radio modules is
documented in <a class="citation-reference" href="#tep104" id="id6" name="id6">[TEP104]</a> and <a class="citation-reference" href="#tep105" id="id7" name="id7">[TEP105]</a>.</p>
</div>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id32" id="conclusion" name="conclusion">6&nbsp;&nbsp;&nbsp;Conclusion</a></h1>
<p>The referenced TEPs in the previous section show that the three-layer
design can be successfully used for exposing to the applications the
functionality of the main hardware modules. The proposed architecture
provides a set of core services that eliminate duplicated code and
provide a coherent view of the system across different architectures
and platforms. It supports the concurrent use of platform-independent
and the platform-dependent interfaces in the same application. In this
way, applications can localize their platform dependence to only the
places where performance matters, while using standard cross-platform
hardware interfaces for the remainder of the application.</p>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id33" id="author-s-address" name="author-s-address">7&nbsp;&nbsp;&nbsp;Author's Address</a></h1>
<div class="line-block">
<div class="line">Vlado Handziski (handzisk at tkn.tu-berlin.de) <a class="footnote-reference" href="#id14" id="id8" name="id8">[1]</a></div>
<div class="line">Joseph Polastre (polastre at cs.berkeley.edu) <a class="footnote-reference" href="#id15" id="id9" name="id9">[2]</a></div>
<div class="line">Jan-Hinrich Hauer (hauer at tkn.tu-berlin.de) <a class="footnote-reference" href="#id14" id="id10" name="id10">[1]</a></div>
<div class="line">Cory Sharp (cssharp at eecs.berkeley.edu) <a class="footnote-reference" href="#id15" id="id11" name="id11">[2]</a></div>
<div class="line">Adam Wolisz (awo at ieee.org) <a class="footnote-reference" href="#id14" id="id12" name="id12">[1]</a></div>
<div class="line">David Culler (culler at eecs.berkeley.edu) <a class="footnote-reference" href="#id15" id="id13" name="id13">[2]</a></div>
</div>
<table class="docutils footnote" frame="void" id="id14" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a name="id14">[1]</a></td><td><em>(<a class="fn-backref" href="#id8">1</a>, <a class="fn-backref" href="#id10">2</a>, <a class="fn-backref" href="#id12">3</a>)</em> Technische Universitaet Berlin
Telecommunication Networks Group
Sekr. FT 5, Einsteinufer 25
10587 Berlin, Germany</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id15" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a name="id15">[2]</a></td><td><em>(<a class="fn-backref" href="#id9">1</a>, <a class="fn-backref" href="#id11">2</a>, <a class="fn-backref" href="#id13">3</a>)</em> University of California, Berkeley
Computer Science Department
Berkeley, CA 94720 USA</td></tr>
</tbody>
</table>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id34" id="citations" name="citations">8&nbsp;&nbsp;&nbsp;Citations</a></h1>
<table class="docutils citation" frame="void" id="haa2005" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1" name="haa2005">[HAA2005]</a></td><td>V. Handziski, J.Polastre, J.H.Hauer, C.Sharp,
A.Wolisz and D.Culler, &quot;Flexible Hardware Abstraction for Wireless
Sensor Networks&quot;, in <em>Proceedings of the 2nd European Workshop on
Wireless Sensor Networks (EWSN 2005)</em>, Istanbul, Turkey, 2005.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="tep1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2" name="tep1">[TEP1]</a></td><td><ol class="first last upperalpha simple" start="16">
<li>Levis, &quot;TEP structure and key words&quot;</li>
</ol>
</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="tep101" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4" name="tep101">[TEP101]</a></td><td>J.H. Hauer, V. Handziski, J. Polastre, L. Nachman,
&quot;Analog-to-digital Converter Abstraction&quot;</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="tep102" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3" name="tep102">[TEP102]</a></td><td><ol class="first last upperalpha simple" start="3">
<li>Sharp, &quot;Clock and Timers Abstraction&quot;</li>
</ol>
</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="tep103" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5" name="tep103">[TEP103]</a></td><td><ol class="first last upperalpha simple" start="4">
<li>Gay, J. Hui, &quot;Non-volatile Storage Abstraction&quot;</li>
</ol>
</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="tep104" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id6" name="tep104">[TEP104]</a></td><td><ol class="first last upperalpha simple" start="11">
<li>Klues, &quot;Radio Hardware Abstraction&quot;</li>
</ol>
</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="tep105" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id7" name="tep105">[TEP105]</a></td><td><ol class="first last upperalpha simple" start="10">
<li>Polastre, &quot;Link Layer Primitives in TinyOS&quot;</li>
</ol>
</td></tr>
</tbody>
</table>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
sentence-end-double-space: t
fill-column: 70
End: -->
</div>
</div>
</body>
</html>
