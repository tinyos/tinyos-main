<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.10: http://docutils.sourceforge.net/" />
<title>Dissemination of Small Values</title>
<meta name="author" content="Philip Levis and Gilman Tolle" />
<style type="text/css">

/*
:Author: David Goodger
:Contact: goodger@users.sourceforge.net
:date: $Date: 2009-02-03 23:07:32 $
:version: $Revision: 1.12 $
:copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.
*/
body {
  font-family: Times;
  font-size: 16px;
}

.first {
  margin-top: 0 ! important }

.last {
  margin-bottom: 0 ! important }

.hidden {
  display: none }

a.toc-backref {
  text-decoration: none ;
  color: black }

blockquote.epigraph {
  margin: 2em 5em ; }

dd {
  margin-bottom: 0.5em }

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.attention, div.caution, div.danger, div.error, div.hint,
div.important, div.note, div.tip, div.warning, div.admonition {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

div.hint p.admonition-title, div.important p.admonition-title,
div.note p.admonition-title, div.tip p.admonition-title,
div.admonition p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em }

div.footer, div.header {
  font-size: smaller }

div.line-block {
  display: block ;
  margin-top: 1em ;
  margin-bottom: 1em }

div.line-block div.line-block {
  margin-top: 0 ;
  margin-bottom: 0 ;
  margin-left: 1.5em }

div.sidebar {
  margin-left: 1em ;
  border: medium outset ;
  padding: 0em 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1 {
  font-family: Arial, sans-serif;
  font-size: 20px;
}

h1.title {
 text-align: center;
 font-size: 32px;
}

h2 {
 font-size: 16px;
 font-family: Arial, sans-serif;
}

h2.subtitle {
  text-align: center }

h3 {
 font-size: 12px;
 font-family: Arial, sans-serif;
}

hr {
  width: 75% }

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font-family: serif ;
  font-size: 100% }

pre.line-block {
  font-family: serif ;
  font-size: 100% }

pre.literal-block, pre.doctest-block {
  margin-left: 2em ;
  margin-right: 2em ;
  background-color: #eeeeee;
  border-color: #000000;
  border-width: thin;
  font-size: 14px
}

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.option-argument {
  font-style: italic }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

table {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.citation {
  border-left: solid thin gray ;
  padding-left: 0.5ex }

table.docinfo {
  margin: 2em 4em;
}

table.footnote {
  border-left: solid thin black ;
  padding-left: 0.5ex }

td, th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

th.docinfo-name, th.field-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap;
  }

h1 tt, h2 tt, h3 tt, h4 tt, h5 tt, h6 tt {
  font-size: 100% }

tt {}

ul.auto-toc {
  list-style-type: none }


</style>
</head>
<body>
<div class="document" id="dissemination-of-small-values">
<h1 class="title">Dissemination of Small Values</h1>
<table class="docinfo" frame="void" rules="none">
<col class="docinfo-name" />
<col class="docinfo-content" />
<tbody valign="top">
<tr class="field"><th class="docinfo-name">TEP:</th><td class="field-body">118</td>
</tr>
<tr class="field"><th class="docinfo-name">Group:</th><td class="field-body">Net2 Working Group</td>
</tr>
<tr class="field"><th class="docinfo-name">Type:</th><td class="field-body">Documentary</td>
</tr>
<tr><th class="docinfo-name">Status:</th>
<td>Final</td></tr>
<tr class="field"><th class="docinfo-name">TinyOS-Version:</th><td class="field-body">2.x</td>
</tr>
<tr><th class="docinfo-name">Author:</th>
<td>Philip Levis and Gilman Tolle</td></tr>
</tbody>
</table>
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last">This memo documents a part of TinyOS for the TinyOS Community, and
requests discussion and suggestions for improvements.  Distribution
of this memo is unlimited. This memo is in full compliance with
TEP 1.</p>
</div>
<div class="section" id="abstract">
<h1>Abstract</h1>
<p>The memo documents the interfaces, components, and semantics for
disseminating small (smaller than a single packet payload) pieces of
data in TinyOS 2.x.  Dissemination establishes eventual consistency
across the entire network on a shared variable and tells an
application when the variable changes. Common uses of this mechanism
include network reconfiguration and reprogramming.</p>
</div>
<div class="section" id="introduction">
<h1>1. Introduction</h1>
<p>Dissemination is a service for establishing eventual consistency on a
shared variable. Every node in the network stores a copy of this
variable. The dissemination service tells nodes when the value
changes, and exchanges packets so it will reach eventual consistency
across the network. At any given time, two nodes may disagree, but
over time the number of disagreements will shrink and the network will
converge on a single value.</p>
<p>Eventual consistency is robust to temporary disconnections or high
packet loss. Unlike flooding protocols, which are discrete efforts
that terminate and not reach consistency, dissemination assures that
the network will reach consensus on the value as long as it is not
disconnected.</p>
<p>Depending on the size of the data item, dissemination protocols can
differ greatly: efficiently disseminating tens of kilobytes of a
binary requires a different protocol than disseminating a two-byte
configuration constant. Looking more deeply, however, there are
similarities. Separating a dissemination protocol into two parts ---
control traffic and data traffic --- shows that while the data traffic
protocols are greatly dependent on the size of the data item, the
control traffic tends to be the same or very similar. For example, the
Deluge binary reprogramming service disseminates metadata about the
binaries. When nodes learn the disseminated metadata differs from the
metadata of their local binary, they know they either have a bad
binary or need a new one.</p>
<p>Novelty is an explicit consideration in dissemination's consistency
model: it seeks to have every node agree on the most recent version of
the variable. In this way, a node can prompt the network to reach
consistency on a new value for a variable by telling the network it is
newer. If several nodes all decide to update the variable,
dissemination ensures that the network converges on a single one of
the updates.</p>
<p>Consistency does not mean that every node will see every possible
value the variable takes: it only means that the network will
eventually agree on what the newest is. If a node is disconnected from
a network and the network goes through eight updates to a shared
variable, when it rejoins the network it will only see the most
recent.</p>
<p>Being able to disseminate small values into a network is a useful
building block for sensornet applications. It allows an administrator
to inject small programs, commands, and configuration constants.  For
example, installing a small program through the entire network can be
cast as the problem of establishing consistency on a variable that
contains the program.</p>
<p>The rest of this document describes a set of components and interfaces
for a dissemination service included in TinyOS 2.0. This service only
handles small values that can fit in a single packet. Larger values
require different interfaces and abstractions.</p>
</div>
<div class="section" id="dissemination-interfaces">
<h1>2. Dissemination interfaces</h1>
<p>Small-value dissemination has two interfaces: DisseminationValue and
DisseminationUpdate. The former is for consumers of a disseminated
value, the latter is for producers. They are as follows:</p>
<pre class="literal-block">
interface DisseminationValue&lt;t&gt; {
  command const t* get();
  command void set(const t*);
  event void changed();
}

interface DisseminationUpdate&lt;t&gt; {
  command void change(t* newVal);
}
</pre>
<p>These interfaces assume that the dissemination service allocates space
to store the variable. In that way, multiple components can all access
and share the same variable that the dissemination service establishes
consistency over. A consumer can obtain a const pointer to the data
through DissemnationValue.get(). It MUST NOT store this pointer, as it
may not be constant across updates.  Additionally, doing so wastes
RAM, as it can be easily re-obtained.  The service signals a changed()
event whenever the dissemination value changes, in case the consumer
needs to perform some computation on it or take some action.</p>
<p>DisseminationValue has a command, ''set'', which allows a node to
change its local copy of a value without establishing consistency.
This command exists so a node can establish an initial value for the
variable. A node MUST NOT call ''set'' after it has handled a
''changed'' event, or the network may become inconsistent. If a node
has received an update or a client has called ''change'' then set MUST
NOT apply its new value.</p>
<p>DisseminationUpdate has a single command, ''change'', which takes a
pointer as an argument. This pointer is not stored: a provider of
DisseminationUpdate MUST copy the data into its own allocated memory.
DisseminationValue MUST signal ''changed'' in response to a
call to ''change''.</p>
<p>A dissemination protocol MUST reach consensus on the newest value in a
network (assuming the network is connected).  Calling change
implicitly makes the data item &quot;newer&quot; so that it will be disseminated
to every node in the network. This change is local, however. If a node
that is out-of-date also calls change, the new value might not
disseminate, as other nodes might already have a newer value. If two
nodes call change at the same time but pass different values, then the
network might reach consensus when nodes have different values. The
dissemination protocol therefore MUST have a tie-breaking mechanism,
so that eventually every node has the same data value.</p>
</div>
<div class="section" id="dissemination-service">
<h1>3 Dissemination Service</h1>
<p>A dissemination service MUST provide one component, DisseminatorC,
which has the following signature:</p>
<pre class="literal-block">
generic configuration DisseminatorC(typedef t, uint16_t key) {
  provides interface DisseminationValue &lt;t&gt;;
  provides interface DisseminationUpdate &lt;t&gt;;
}
</pre>
<p>The t argument MUST be able to fit in a single message_t [TEP111]
after considering the headers that the dissemination protocol
introduces.  A dissemination implementation SHOULD have a compile
error if a larger type than this is used.</p>
<p>As each instantiation of DisseminatorC probably allocates storage and
generates code, if more than one component wants to share a
disseminated value then they SHOULD encapsulate the value in a
non-generic component that can be shared. E.g.:</p>
<pre class="literal-block">
configuration DisseminateTxPowerC {
  provides interface DisseminationValue&lt;uint8_t&gt;;
}
implementation {
  components new DisseminatorC(uint8_t, DIS_TX_POWER);
  DisseminationValue = DisseminatorC;
}
</pre>
<p>Two different instances of DisseminatorC MUST NOT share the same value
for the <tt class="docutils literal">key</tt> argument.</p>
</div>
<div class="section" id="dissemination-keys">
<h1>4 Dissemination Keys</h1>
<p>One issue that comes up when using these interfaces is the selection
of a key for each value. On one hand, using unique() is easy, but this
means that the keyspaces for two different compilations of the same
program might be different and there's no way to support a network
with more than one binary. On the other hand, having a component
declare its own key internally means that you can run into key
collisions that can't be resolved. In the middle, an application can
select keys on behalf of other components.</p>
<p>Ordinarily, dissemination keys can be generated by unique or selected
by hand. However, these defined keys can be overridden by an
application-specific header file. The unique namespace and the static
namespace are separated by their most significant bit. A component
author might write something like this:</p>
<pre class="literal-block">
#include &lt;disseminate_keys.h&gt;
configuration SomeComponentC {
  ...
}
implementation {
#ifndef DIS_SOME_COMPONENT_KEY
  enum {
    DIS_SOME_COMPONENT_KEY = unique(DISSEMINATE_KEY) + 1 &lt;&lt; 15;
  };
#endif
  components SomeComponentP;
  components new DisseminatorC(uint8_t, DIS_SOME_COMPONENT_KEY);
  SomeComponentP.ConfigVal -&gt; DisseminatorC;
}
</pre>
<p>To override, you can then make a disseminate_keys.h in your app
directory:</p>
<pre class="literal-block">
#define DIS_SOME_COMPONENT_KEY 32
</pre>
<p>Even with careful key selection, two incompatible binaries with
keyspace collisions may end up in the same network. If this happens, a
GUID that's unique to a particular binary MAY be included in the
protocol. The GUID enables nodes to detect versions from other
binaries and not store them. This GUID won't be part of the external
interface, but will be used internally.</p>
</div>
<div class="section" id="more-complex-dissemination">
<h1>5. More Complex Dissemination</h1>
<p>An application can use this low-level networking primitive to build
more complex dissemination systems. For example, if you want have a
dissemination that causes only nodes which satisfy a predicate to
apply a change, you can do that by making the &lt;t&gt; a struct that stores
a predicate and data value in it, and layering the predicate
evaluation on top of the above interfaces.</p>
</div>
<div class="section" id="implementation">
<h1>6. Implementation</h1>
<p>Two implementations of this TEP exist and can be found in
<tt class="docutils literal"><span class="pre">tinyos-2.x/tos/lib/net</span></tt>. The first, Drip, can be found in
''tinyos-2.x/tos/lib/net/drip''. The second, DIP, can be found in
''tinyos-2.x/tos/lib/net/dip''. Both implementations are based on the
Trickle algorithm[2]_. Drip is a simple, basic implementation that
establishes an independent trickle for each variable. DIP uses a more
complex approach involving hash trees, such that it is faster,
especially when the dissemination service is maintaining many
variables[3]_. This complexity, however, causes DIP to use more
program memory.</p>
</div>
<div class="section" id="author-s-address">
<h1>6. Author's Address</h1>
<div class="line-block">
<div class="line">Philip Levis</div>
<div class="line">358 Gates Hall</div>
<div class="line">Computer Science Laboratory</div>
<div class="line">Stanford University</div>
<div class="line">Stanford, CA 94305</div>
<div class="line"><br /></div>
<div class="line">phone - +1 650 725 9046</div>
<div class="line"><br /></div>
<div class="line"><br /></div>
<div class="line">Gilman Tolle</div>
<div class="line">2168 Shattuck Ave.</div>
<div class="line">Arched Rock Corporation</div>
<div class="line">Berkeley, CA 94704</div>
<div class="line"><br /></div>
<div class="line">phone - +1 510 981 8714</div>
<div class="line">email - <a class="reference external" href="mailto:gtolle&#64;archedrock.com">gtolle&#64;archedrock.com</a></div>
</div>
</div>
<div class="section" id="citations">
<h1>7. Citations</h1>
<table class="docutils footnote" frame="void" id="id1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td>TEP 111: message_t.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[2]</td><td>Philip Levis, Neil Patel, David Culler, and Scott Shenker. &quot;Trickle: A Self-Regulating Algorithm for Code Maintenance and Propagation in Wireless Sensor Networks.&quot; In Proceedings of the First USENIX/ACM Symposium on Networked Systems Design and Implementation (NSDI 2004).</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[3]</td><td>Kaisen Lin and Philip Levis. &quot;Data Discovery and Dissemination with DIP.&quot; In Proceedings of the Proceedings of the Seventh International Conference on Information Processing in Wireless Sensor Networks (IPSN), 2008.</td></tr>
</tbody>
</table>
</div>
</div>
</body>
</html>
